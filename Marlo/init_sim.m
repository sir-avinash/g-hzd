function opts = init_sim(obj, tSpan, x0, varargin )


    nx = numel(obj.states);
	nu = numel(obj.inputs);

    % Parse input arguments
	parser = inputParser;
	parser.addRequired('timeSpan', ...
		@(x) validateattributes(x, ...
			{'double'}, {'vector'}));
	parser.addRequired('initialState', ...
		@(x) validateattributes(x, {'double'}, {'numel', nx}));
	parser.addOptional('initialMode', obj.modes{1}, ...
		@(x) ischar(validatestring(x, obj.modes)));
	parser.addOptional('maxModes', inf, ...
		@(x) validateattributes(x, {'double'}, {'scalar', 'positive'}));
	parser.addOptional('controller', @(t,x,stepHeight) 0, ...
		@(x) validateattributes(x, {'function_handle'}, {}));
	parser.addOptional('solver', 'ode45', ...
		@(x) ischar(validatestring(x, ...
			{'ode45', 'ode23', 'ode113', 'ode15s', 'ode23s', 'ode23t', 'ode23tb'})));
    parser.addOptional('stepHeight', zeros(1,100),...
		@(x) validateattributes(x, {'double'}, {'vector'}));
    parser.addOptional('stepLength', zeros(1,100),...
		@(x) validateattributes(x, {'double'}, {'vector'}));
    parser.addOptional('shape', 'linear', ...
		@(x) ischar(validatestring(x, {'linear','nearest'})));
    parser.addOptional('CheckEvent', false,...
		@(x) validateattributes(x, {'logical'}, {'scalar'}));
    parser.addOptional('stepCount', inf,...
		@(x) validateattributes(x, {'double'}, {'scalar', 'positive'}));
    
	parser.parse(tSpan, x0, varargin{:});
	opts = parser.Results;

	% Convert solver string to function handle
	opts.solver = str2func(opts.solver);

	